// Package ctr implements the CTR rand scheme with a random IV.
package ctr

import (
	"crypto/aes"
	"fmt"
	"math/big"
)

// BlockSize is the size of the message blocks.
// We use AES 128.
const BlockSize = 16

// Encrypt encrypts the given message.
// The IV needs to be randomly generated by the client.
func Encrypt(iv, key, m []byte) ([]byte, error) {
	if len(iv) != BlockSize {
		return nil, fmt.Errorf("invalid IV: expected %d bytes, got %d", BlockSize, len(iv))
	}

	if len(key) != BlockSize {
		return nil, fmt.Errorf("invalid key: expect %d bytes, got %d", BlockSize, len(key))
	}

	blockCipher, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	res := make([]byte, len(m)+BlockSize)

	// The first block contains the IV
	for i := 0; i < BlockSize; i++ {
		res[i] = iv[i]
	}

	for i := 0; i < len(m)/BlockSize; i++ {
		encryptedIV := make([]byte, BlockSize)
		blockCipher.Encrypt(encryptedIV, add(iv, i))
		encryptedBlock := xor(
			encryptedIV,
			m[i*BlockSize:(i+1)*BlockSize],
		)

		for j := 0; j < BlockSize; j++ {
			res[(i+1)*BlockSize+j] = encryptedBlock[j]
		}
	}

	// Last incomplete block if message isn't a multiple of BlockSize.
	if len(m)%BlockSize > 0 {
		encryptedIV := make([]byte, BlockSize)
		blockCipher.Encrypt(encryptedIV, add(iv, len(m)/BlockSize))
		encryptedBlock := xor(
			encryptedIV,
			m[len(m)-(len(m)%BlockSize):],
		)

		for j := 0; j < len(encryptedBlock); j++ {
			res[BlockSize*(1+len(m)/BlockSize)+j] = encryptedBlock[j]
		}
	}

	return res, nil
}

// add adds an integer to an IV (which means it has BlockSize length).
// Since messages are small we can limit n to an int16.
func add(b []byte, n int) []byte {
	iv := new(big.Int)
	iv.SetBytes(b)

	nn := new(big.Int)
	nn.SetInt64(int64(n))

	iv.Add(iv, nn)
	unpadded := iv.Bytes()
	res := make([]byte, BlockSize)
	for i := 0; i < len(unpadded); i++ {
		res[BlockSize-len(unpadded)+i] = unpadded[i]
	}

	return res
}

// xor xors two byte arrays together.
// The arrays can have different length, the smallest one will be used.
func xor(b1, b2 []byte) []byte {
	var smallest, biggest []byte
	if len(b1) > len(b2) {
		smallest = b2
		biggest = b1
	} else {
		smallest = b1
		biggest = b2
	}

	res := make([]byte, len(smallest))
	for i := 0; i < len(res); i++ {
		res[i] = smallest[i] ^ biggest[i]
	}

	return res
}

// Decrypt decrypts the given cipher text.
// The cipher text needs to be correctly encoded with rand CTR.
func Decrypt(key, c []byte) ([]byte, error) {
	if len(key) != BlockSize {
		return nil, fmt.Errorf("invalid key: expect %d bytes, got %d", BlockSize, len(key))
	}

	blockCipher, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	// First block if the IV.
	iv := c[:BlockSize]

	// Remove iv from cipher for the rest of the operations.
	c = c[BlockSize:]
	message := make([]byte, len(c))

	for i := 0; i < len(c)/BlockSize; i++ {
		encryptedIV := make([]byte, BlockSize)
		blockCipher.Encrypt(encryptedIV, add(iv, i))
		block := xor(encryptedIV, c[i*BlockSize:(i+1)*BlockSize])
		for j := 0; j < BlockSize; j++ {
			message[i*BlockSize+j] = block[j]
		}
	}

	// Last incomplete block if message isn't a multiple of BlockSize.
	if len(c)%BlockSize > 0 {
		encryptedIV := make([]byte, BlockSize)
		blockCipher.Encrypt(encryptedIV, add(iv, len(c)/BlockSize))
		block := xor(encryptedIV, c[len(c)-(len(c)%BlockSize):])
		for j := 0; j < len(block); j++ {
			message[BlockSize*(len(c)/BlockSize)+j] = block[j]
		}
	}

	return message, nil
}
