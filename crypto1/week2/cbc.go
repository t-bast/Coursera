// Package cbc implements the cbc scheme with a random IV.
package cbc

import (
	"crypto/aes"
	"fmt"
)

// BlockSize is the size of the message blocks.
// We use AES 128.
const BlockSize = 16

// Encrypt encrypts the given message.
// The IV needs to be randomly generated by the client.
func Encrypt(iv, key, m []byte) ([]byte, error) {
	if len(iv) != BlockSize {
		return nil, fmt.Errorf("invalid IV: expected %d bytes, got %d", BlockSize, len(iv))
	}

	if len(key) != BlockSize {
		return nil, fmt.Errorf("invalid key: expect %d bytes, got %d", BlockSize, len(key))
	}

	blockCipher, err := aes.NewCipher(key)
	if err != nil {
		return nil, err
	}

	padded := pad(m)
	if len(padded)%BlockSize != 0 {
		return nil, fmt.Errorf("invalid padding: %d total bytes", len(padded))
	}

	res := make([]byte, len(padded)+BlockSize)

	// The first block contains the IV
	for i := 0; i < BlockSize; i++ {
		res[i] = iv[i]
	}

	// We XOR each message block with the previously encrypted block.
	for i := 0; i < len(padded)/BlockSize; i++ {
		block := xor(
			res[i*BlockSize:(i+1)*BlockSize],
			padded[i*BlockSize:(i+1)*BlockSize])

		encrypted := make([]byte, BlockSize)
		blockCipher.Encrypt(encrypted, block)

		for j := 0; j < BlockSize; j++ {
			res[(i+1)*BlockSize+j] = encrypted[j]
		}
	}

	return res, nil
}

// pad pads the message so that it's a multiple of the BlockSize.
// Let X be the number of bytes in the last block.
//	* If X < 16: we insert Y=16-X bytes containing Y at the end
//	* If X = 16: we insert a full padding block containing 16 times 00010000 (0x10)
func pad(m []byte) []byte {
	res := m[:]
	var padSize byte
	if len(m)%BlockSize == 0 {
		padSize = BlockSize
	} else {
		padSize = byte(BlockSize - (len(m) % BlockSize))
	}

	var i byte
	for i = 0; i < padSize; i++ {
		res = append(res, padSize)
	}

	return res
}

// xor xors two byte arrays.
// It assumes that the arrays have the same length.
func xor(b1, b2 []byte) []byte {
	res := make([]byte, len(b1), len(b1))
	for i := 0; i < len(b1); i++ {
		res[i] = b1[i] ^ b2[i]
	}

	return res
}

// Decrypt decrypts the given cipher text.
// The cipher text needs to be correctly encoded with CBC.
func Decrypt(key, c []byte) []byte {
	return nil
}
